# R

특징

* hive 연동
* java 연동
* 통계 언어
* python은 프로그래머용이고, R은 통계학자용이다.



주석 : \#

R, RSTUDIO



## data type

### 변수

알파벳,숫자,언더바,마침표로 구성되며 -(바)는 쓸수 없다. 첫글자는 알파벳 또는 마침표로 시작할수 없다. 마침표로 시작한다면, 마침표 뒤에 바로 숫자가 올수는 없다.

변수 타입이 없음

R에서 데이터 타입의 기본은 vector이다. 

#### 변수값 할당

<- 는 어느곳에서나 쓸수 있지만,

= 는 명령의 최상위 수준에서만 가능(?)

#### scalar

```R
> a <- 3
> b <- 4.5
> c <- a + b
> print(c)
[1] 7.5
> c
[1] 7.5
>
```



* NA(not available) : 넣고 싶은데 측정되거나 정언된 값이 없다!

  ```R
  > four <- NA
  ```

* NULL : 값이 있으나 프로그래밍 상으로 초기화 되지 않음

  ```R
  > x <- NULL
  ```

* TRUE & FALSE

#### Factor

사전에 지정된 값만 가질수 있음

```R
factor(
   X,       # 팩터로 표현하고자 하는 값(주로 문자열 벡터로 지정)
   levels,  # 값의 레벨
   ordered  # TRUE면 순서형, FALSE면 명목형 데이터를 뜻한다. 기본값은 FALSE>다.
)

> sex <- factor("m", c("m", "f"))
> sex
[1] m
Levels: m f
```



* 명목형

  \- 값들간에 비교가 불가능한 경우

* 수치형

  \- 숫자로 나온 값

#### verctor 

배열의 개념으로, 한가지 스칼라 데이터 타입의 데이터를 저장할 수 있다. 

R의 벡터는 슬라이스를 제공한다. 슬라이스란 배열의 일부를 잘라낸 뒤 이를 또 다시 배열처럼 다루는 개념이다.

또한 벡터의 각 셀에는 이름을 부여할 수 있다.(인덱스에 이름을 붙임)

벡터는 중첩할 수 없다. 따라서 벡터 안에 벡터를 생성하면 단일 차원의 벡터로 변경된다. 중첩된 구조가 필요하다면 역시 리스트를 사용해야 한다.

##### C

주어진 값들을 모아 벡터를 생성한다.

```R
c(
   ...  # 벡터로 모을 R 객체들
)

> (x <- c(1, 2, 3, 4, 5))
[1] 1 2 3 4 5

> c(1, 2, 3, c(1, 2, 3))
[1] 1 2 3 1 2 3
```

벡터 데이터 접근

| 문법          | 의미                                                         |
| ------------- | ------------------------------------------------------------ |
| x[n]          | 벡터 x의 n번째 요소. n은 숫자 또는 셀의 이름을 뜻하는 문자열 |
| x[-n]         | 벡터 x에서 n번째 요소를 제외한 나머지. n은 숫자 또는 셀의 이름을 뜻하는 문자열 |
| x[idx_vector] | 벡터 x로부터 idx_vector에 지정된 요소를 얻어옴. 이때 idx_vector는 색인을 표현하는 숫자 벡터 또는 셀의 이름을 표현하는 문자열 벡터 |
| x[start:end]  | 벡터 x의 start부터 end까지의 값을 반환함. 반환 값은 start 위치의 값과 end 위치의 값을 모두 포함함 |

##### seq

연속된 숫자로 구성된 벡터

```R
seq(
  from,  # 시작 값 
  to,    # 끝 값 
  by     # 증가치 
)
> seq(3, 7, 2)  # 2씩 증가
[1] 3 5 7
```

##### rep

반복된 값이 저장된 벡터는 req로 생성할 수 있다.

```R
rep(
   x,      # 반복할 값이 저장된 벡터 
   times,  # 전체 벡터의 반복 횟수 
   each    # 개별 값의 반복 횟수 
)

> rep(1:2, times=5)
[1] 1 2 1 2 1 2 1 2 1 2
```



#### List

(키, 값)의 형태를 띄는 연관 배열이다.

벡터와 달리 값이 서로 다른 데이터타입을 담을 수 있다.

```R
list(
   key1=value1, 
   key2=value2, 
   ... 
)
> (x <- list(name="foo", height=c(1, 3, 5)))
> list (a=list(val=c(1, 2, 3)), b=list(val=c(1, 2, 3, 4)))
```



##### 리스트 데이터 접근

| 문법  | 의미                                   |
| ----- | -------------------------------------- |
| x$key | 리스트 x에서 키 값 key에 해당하는 값   |
| x[n]  | 리스트 x에서 n번째 데이터의 서브리스트 |
| x     | 리스트 x에서 n번째 저장된 값           |

```R
> x <- list(name="foo", height=c(1, 3, 5))
> x$name
[1] "foo"
> x$height
[1] 1 3 5
> x1
[1] "foo"
> x2
[1] 1 3 5
```



#### 행렬(matrix)

2차원 배열

한가지 타입의 데이터만 들어간다.

```R
matrix( 
   data,          # 행렬을 생성할 데이터 벡터 
   nrow,          # 행의 수 
   ncol,          # 열의 수 
   byrow=FALSE,   # TRUE로 설정하면 행우선, FALSE일 경우 열 우선으로 데이터를 채운다. 
   dimnames=NULL  # 행렬의 각 차원에 부여할 이름 
)

> matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow=3)
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
[3,]    3    6    9
```

#### 배열

2차원 이상의 3다차원 배열



#### Data Frame

matrix 비스무리한데 여러가지 타입의 데이터가 들어간다.

문법

| 문법           | 의미                                                         |
| -------------- | ------------------------------------------------------------ |
| d$colname      | 데이터 프레임 d에서 컬럼 이름이 colname인 데이터를 접근한다. |
| d$colname <- y | 데이터 프레임 d에서 컬럼 이름이 colname인 컬럼에 데이터 y를 저장한다. 만약 colname이 d에 없는 새로운 이름이라면 새로운 컬럼이 추가된다. |



### 타입 판별

| 함수             | 의미                                     |
| ---------------- | ---------------------------------------- |
| class(x)         | 객체 x의 클래스                          |
| str(x)           | 객체 x의 내부 구조                       |
| is.factor(x)     | 주어진 객체 x가 팩터인가                 |
| is.numeric(x)    | 주어진 객체 x가 숫자를 저장한 벡터인가   |
| is.character(x)  | 주어진 객체 x가 문자열을 저장한 벡터인가 |
| is.matrix(x)     | 주어진 객체 x가 행렬인가                 |
| is.array(x)      | 주어진 객체 x가 배열인가                 |
| is.data.frame(x) | 주어진 객체 x가 데이터 프레임인가        |

### 타입 변환

| 함수             | 의미                                        |
| ---------------- | ------------------------------------------- |
| as.factor(x)     | 주어진 객체 x를 팩터로 변환                 |
| as.numeric(x)    | 주어진 객체 x를 숫자를 저장한 벡터로 변환   |
| as.character(x)  | 주어진 객체 x를 문자열을 저장한 벡터로 변환 |
| as.matrix(x)     | 주어진 객체 x를 행렬로 변환                 |
| as.array(x)      | 주어진 객체 x를 배열로 변환                 |
| as.data.frame(x) | 주어진 객체 x를 데이터 프레임으로 변환      |



## R programming

특이사항

* 전체 데이터를 한번에 다루는 벡터연산을더 자주 사용한다.
* NA(not availavble)의 존재
* R 객체는 대부분 값을 수정할 수 없다.

### if ~ else

| 문법                                                         | 의미                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `if (cond) {    cond가 참일 때 실행할 문장 } else {    cond가 거짓일 때 실행할 문장 }` | 조건 cond가 참, 거짓인 경우에 따라 {} 블록을 실행한다. 필요한 경우 else 블록을 지정할 수 있다. |

```
ifelse(
 test, # 참, 거짓을 저장한 객체
 yes, # test가 참일 때 선택할 값
 no # test가 거짓일 때 선택할 값
)
```

### for

| 문법                                            | 의미                                                         |
| ----------------------------------------------- | ------------------------------------------------------------ |
| `for (i in data) {   i를 사용한 문장 }`         | data에 들어 있는 각각의 값을 변수 i에 할당하면서 각각에 대해 블록 안의 문장을 수행한다. |
| `while (cond) {   조건이 참일 때 수행할 문장 }` | 조건 cond가 참일 때 블록 안의 문장을 수행한다.               |
| `repeat {   반복해서 수행할 문장 }`             | 블록 안의 문장을 반복해서 수행한다. repeat은 다른 언어의 do-while에 해당한다. |

break : 잘 아는 그거

next : continue

### 연산

<p style="color:red"> NA 조심!!</p>

#### 수치 연산

| 연산자와 함수          | 의미                                                   |
| ---------------------- | ------------------------------------------------------ |
| +, -, *, /             | 사칙 연산                                              |
| n %% m                 | n을 m으로 나눈 나머지                                  |
| n %/% m                | n을 m으로 나눈 몫                                      |
| n^m                    | n의 m승                                                |
| exp(n)                 | e의 n승                                                |
| log(x, base=exp(1))    | logbase(x). 만약 base가 지정되지 않으면 loge(x)를 계산 |
| log2(x), log10(x)      | 각각 log2(x), log10(x)를 계산                          |
| sin(x), cos(x), tan(x) | 삼각 함수                                              |

#### 벡터 연산

#### NA의 처리

| 함수                    | 의미                                                         |
| ----------------------- | :----------------------------------------------------------- |
| na.fail(object, ...)    | object에 NA가 포함되어 있으면 실패한다.                      |
| na.omit(object, ...)    | object에 NA가 포함되어 있으면 이를 제외한다.                 |
| na.exclude(object, ...) | object에 NA가 포함되어 있으면 이를 제외한다는 점에서 na.omit과 동일하다. 그러나 naresid, napredict를 사용하는 함수에서 NA로 제외한 행을 결과에 다시 추가한다는 점이 다르다. |
| na.pass(object, ...)    | object에 NA가 포함되어 있더라도 통과시킨다.                  |
| na.rm=true              | object에 NA가 포함되어 있으면 삭제시킨다.                    |

### 함수의 정의

```R
function_name <- function(인자, 인자, ...) {
  함수 본문
  return(반환 값)  # 반환 값이 없다면 생략
}

> fibo <- function(n) {
+   if (n == 1 || n == 2) {
+     return(1)
+   }
+   return(fibo(n - 1) + fibo(n - 2))
+ }
```

#### 가변길이인자

인자의 길이가 몇개로 정의되어있지 않다. 

```R
> f <- function(...) {
+   args <- list(...)
+   for (a in args) {
+     print(a)
+   }
+ }
> f('3', '4')
[1] "3"
[1] "4"
```

#### 중첩함수

함수 안에 또 다른 함수를 정의하여 사용할 수 있다.

```R
> f <- function(x, y) {
+   print(x)
+   g <- function(y) {
+     print(y)
+   }
+   g(y)
+ }
> f(1, 2)
[1] 1
[1] 2
```

### scope

R에서는 문법적 스코프를 사용하며, 문법적 스코프는 변수가 정의된 블록 내부에서만 변수를 접근할 수 있는 규칙을 말한다.

* 전역변수가 선언되면, 함수 내에서도 사용 가능하다.
* 함수 내부에서 전역 변수와 같은 이름의 지역 변수를 사용하면, 함수 내부의 지역 변수가 우선한다.
* 함수 내부에서도, 전역 변수로도 선언되지 않은 이름을 사용하면 에러다.
* 함수 내에서 이름은 함수 안의 변수들로부터 먼저 찾는다. 같은 이유로 함수 인자의 변수명 역시 전역 변수보다 우선한다.
* 중첩 함수에도 같은 규칙이 적용된다. 
* 그러나 만약 함수 f( )마저도 변수 a를 포함하고 있지 않다면 전역 변수 a를 사용하게 된다.

메모리상의 객체 관련 함수

```R
rm(
  ...,                       # 삭제할 객체의 목록
  list=character(),          # 삭제할 객체를 나열한 벡터
  envir=as.environment(pos)  # 객체를 삭제할 환경
)

ls(
  name, # 객체를 나열할 환경의 이름
  envir # name 대신 직접 환경을 지정할 경우 사용
)
```



#### call by value

객체는 함수 호출 시 일반적으로 값으로 전달된다.

그러므로 함수 내에서 값을 바꾸면 함수가 끝나고 값이 원래대로 돌아온다.

